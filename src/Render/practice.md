# Pipeline

![](../assets/v2-99ab1ed51db4352046c34fa0df8d36b7_1440w.png)

绘制的最核心工作就是计算（Computation）。

- 投影。我们设定一个相机位置，然后对物体进行投影（无论是正交投影还是透视投影），就可以得到屏幕空间中的三角形。
- 光栅化。将屏幕空间中的三角形光栅化成一个个的像素。
- 着色，也叫做绘制。着色器代码将自己所处理的像素点所对应的纹理贴图上的坐标的相应位置上的颜色值取出。
**进行一次纹理采样，需要采样八个像素点的数据，并且进行七次插值运算。因此，纹理采样是绘制过程中的一个很重要的运算。**

# GPU（Graphic Processing Unit）

随着独立显卡的出现，我们可以将这些复杂的运算用一台更高效的机器进行处理，这样可以释放出大量的CPU时间。

## 基本概念

- SIMD（Single Instruction Multiple Data）

对于一个四维向量来说，每进行一次加法操作，它的XYZW坐标会同时进行运算。所以一条指令就能够完成四个加法或者四个减法运算。

- SIMT（Single Instruction Multiple Threads）

即将一个计算核心做得很小，这样可以同时提供多个计算核心，并且可以同时在多个核心上执行同一条指令。  
如果我们有100个计算核心，向这100个核心发送一条指令，就可以同时进行100次四维向量的加减。相当于将一条指令的计算效能放大了400倍。现代显卡如同一个蜂巢，其中内置了很多小型计算核心。NVIDIA的显卡中就内置了很多称为CUDA的计算核心。这就是现代显卡算力强悍的原因。

![](../assets/v2-c2663488d1e6a768f843315edf539a9c_1440w.png)

- FLOPS （floating-point operations per second）

FLOPS代表着显卡的浮点运算能力，即每秒浮点运算次数。

为什么显卡的算力能够遥遥领先于CPU呢？本质上是因为显卡中具有大量可以同时进行并行计算的小型计算核心，每个核心的功能简单，只可以进行简单的计算。而CPU的核心数量很少，但单个核心的计算能力很强。

因此显卡的并行计算能力十分强大。因此，我们在设计绘制算法的时候，要**尽可能地利用SIMT结构的优势，尽可能使用相同的代码进行并行计算**。这样一来，每个计算核心都可以分别访问自己的数据，这样可以充分发挥显卡架构的优势。

## GPU Architecture

![](../assets/v2-c8a4465ed4f34d30a15698b919369750_r.png)

- ALU（Arithmetic Logic Units，算术逻辑单元）
- SFU（Special Function Unit，特殊功能单元）：专门的硬件处理各种耗时的纹理采样工作，以及一些比较复杂的数学运算。比如正弦、余弦、指数、对数等超越函数运算。
- RT Core：用来加速光线追踪BVH算法的硬件逻辑电路。

在GPU上的运算都会被分配到每个流式多处理器上进行处理。而流式多处理器中的几十个核心不仅可以进行并行处理，相互之间还可以交换数据，从而进行协作。

## 数据传输

我们一直使用的都是冯洛伊曼架构，即将计算和数据分开。这样的架构会让硬件设计变得非常简单。  
冯洛伊曼架构的最大问题是，每一次计算，都需要去获取数据。但是获取数据的操作速度非常慢，而且数据在不同的计算单元（例如CPU和GPU）之间搬来搬去也是非常之慢。  

这一过程存在一个非常严重的问题，在现在引擎架构中，绘制和逻辑通常是不同步的。如果有一步绘制运算需要等待数据，则可能会导致半帧到一帧的延迟（Latency）。

因此，在游戏引擎的绘制系统架构中有一个原则，就是**尽可能将数据单向传输**。即CPU将数据单向发送到显卡，并且尽可能不要从显卡中回读数据。这也是现代计算机结构对渲染系统设计的一个限制。

# Cache

 缓存对于现代计算的性能影响是非常大的，可能远远超过大家的想象。这也是**数据一定要放在一起的原因，其实就是为了缓存去做这样的准备**。因为数据连贯性对于缓存来说非常重要。如果有些数据过大，那么也会导致缓存很难被利用好。

# 可渲染物体

## 网格在游戏引擎中如何表示

- 顶点位置：用索引数据（Index Data）和顶点数据（Vertex Data）来定义三角形的信息
- 、顶点处的法线朝向、顶点的UV坐标，以及其他各种各样的属性